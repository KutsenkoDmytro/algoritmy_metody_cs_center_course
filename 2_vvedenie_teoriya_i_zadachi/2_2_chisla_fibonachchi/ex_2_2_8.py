'''
Задача на программирование повышенной сложности: огромное число Фибоначчи по модулю

Даны целые числа 1≤n≤10**18  и 2≤m≤10**5 , необходимо найти остаток от деления n-го числа Фибоначчи на m.


Sample Input:

10 2
Sample Output:

1
'''



'''
Алгоритм:
Как и в прошлой задаче считаем остатки от деления (F(n) = F(n-2) mod m +  F(n-1) mod m)
и сохраняем их в массив/список. Изначально в массиве должны уже лежать 0 и 1 => [0,1].
Остановиться нужно, когда F(n-2) mod m опять станет равным 0 (не будет остатка от деления),
а F(n-1) mod m - равным 1. Это будет означать, что последовательность начала повторяться.
(https://ru.wikipedia.org/wiki/%D0%9F%D0%B5%D1%80%D0%B8%D0%BE%D0%B4_%D0%9F%D0%B8%D0%B7%D0%B0%D0%BD%D0%BE)
Последние 2 элемента (0 и 1) нужно из этого массива/списка удалить (т.к. с них последовательность начиналась).
По итогу нужно посчитать остаток от деления n на длину этого списка и взять из списка элемент с индексом, равным этому остатку.

Решение - совокупность усилий по поиску в в гугле и чтению комментариев к задаче.
Узнал/понял ли я что-то новое? Нет. Пожалуй, без внятных объяснений я так и не пойму,
почему именно такое решение. Как решить - это да, а вот почему так - это нет. ИМХО,
при таком "объяснении" материала цель курса для меня полная загадка.

'''


#Решение с использованием Периода Пизано

def fib_mod(n, m):

    lst = [0,1]

    for i in range(2, n+1):

        lst.append((lst[-1]+lst[-2]) % m)
        if lst[-2:] == [0,1]:
            lst.pop()
            lst.pop()
            break

    return lst[(n % len(lst))]

def main():
    n, m = map(int, input().split())
    print(fib_mod(n, m))


if __name__ == "__main__":
    main()